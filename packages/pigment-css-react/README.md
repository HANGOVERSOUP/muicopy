# Pigment¬†CSS

Pigment¬†CSS is a zero-runtime CSS-in-JS library that extracts the colocated styles to their own CSS files at build time.

- [Getting started](#getting-started)
  - [Why choose Pigment CSS](#why-choose-pigment-css)
  - [Start with Next.js](#start-with-nextjs)
  - [Start with Vite](#start-with-vite)
- [Basic usage](#basic-usage)
  - [Creating styles](#creating-styles)
  - [Creating components](#creating-components)
    - [Styling based on props](#styling-based-on-props)
    - [Styling based on runtime values](#styling-based-on-runtime-values)
    - [Styled component as a CSS selector](#styled-component-as-a-css-selector)
    - [Typing props](#typing-props)
- [Theming](#theming)
  - [Accesing theme values](#accesing-theme-values)
  - [CSS variables support](#css-variables-support)
  - [Color schemes](#color-schemes)
  - [Switching color schemes](#switching-color-schemes)
  - [TypeScript](#typescript)
- [How-to guides](#how-to-guides)
  - [Coming from Emotion or styled-components](#coming-from-emotion-or-styled-components)

## Getting started

Pigment¬†CSS supports Next.js and Vite; support for other bundlers is coming in the future.
You must install the corresponding plugin as shown below.

### Why choose Pigment¬†CSS

Thanks to recent advancements in CSS (like CSS variables and `color-mix()`), "traditional" CSS-in-JS solutions that process styles at runtime are no longer required for unlocking features like color transformations and theme variables which are necessary for maintaining a sophisticated design system.

Pigment¬†CSS addresses the needs of the modern React developer by providing a zero-runtime CSS-in-JS styling solution as a successor to tools like Emotion and styled-components.

Compared to its predecessors, Pigment¬†CSS offers improved DX and runtime performance (though at the cost of increased build time) while also being compatible with React Server Components.
Pigment¬†CSS is built on top of [WyW-in-JS](https://wyw-in-js.dev/) which helps to provide the smoothest possible experience for Material¬†UI users migrating from Emotion in v5 to Pigment¬†CSS in v6.

### Start with Next.js

Run the following commands to create a new Next.js project with Pigment¬†CSS already set up:

```bash
curl https://codeload.github.com/mui/material-ui/tar.gz/master | tar -xz --strip=2  material-ui-master/examples/pigment-css-nextjs-ts
cd pigment-css-nextjs-ts
```

#### Manual installation

Run the following commands to manually install Pigment¬†CSS in your Next.js project:

```bash
npm install @pigment-css/react
npm install --save-dev @pigment-css/nextjs-plugin
```

Next, in your `next.config.js` file, import the plugin and wrap the exported config object:

```js
const { withPigment } = require('@pigment-css/nextjs-plugin');

module.exports = withPigment({
  // ... Your nextjs config.
});
```

Finally, import the stylesheet in the root `layout.tsx` file:

```diff
 import type { Metadata } from 'next';
+import '@pigment-css/react/styles.css';

 export const metadata: Metadata = {
   title: 'Create Next App',
   description: 'Generated by create next app',
 };

 export default function RootLayout(props: { children: React.ReactNode }) {
   return (
     <html lang="en">
       <body>{props.children}</body>
     </html>
   );
 }
```

### Start with Vite

Run the following commands to create a new Vite project with Pigment¬†CSS already set up:

```bash
curl https://codeload.github.com/mui/material-ui/tar.gz/master | tar -xz --strip=2 material-ui-master/examples/pigment-css-vite-ts
cd pigment-css-vite-ts
```

#### Manual installation

Run the following commands to manually install Pigment¬†CSS in your Vite project:

```bash
npm install @pigment-css/react
npm install --save-dev @pigment-css/vite-plugin
```

Next, in your Vite config file, import the plugin and pass it to the `plugins` array as shown below:

```js
import { pigment } from '@pigment-css/vite-plugin';

export default defineConfig({
  plugins: [
    pigment(),
    // ... Your other plugins.
  ],
});
```

Finally, import the stylesheet in the root `main.tsx` file:

```diff
 import * as React from 'react';
 import { createRoot } from 'react-dom/client';
+import '@pigment-css/react/styles.css';
 import App from './App';

 const rootElement = document.getElementById('root');
 const root = createRoot(rootElement);

 root.render(
   <React.StrictMode>
     <App />
   </React.StrictMode>,
 );
```

## Basic usage

> ‚ö†Ô∏è You must configure Pigment¬†CSS with your bundler‚Äîeither [Next.js](#start-with-nextjs) or [Vite](#start-with-vite)‚Äîbefore proceeding.

### Creating styles

Use the `css` API to create reusable styles.
For example, the snippet below creates a `visuallyHidden` class that can be applied to a component:

```js
import { css } from '@pigment-css/react';

const visuallyHidden = css({
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: '1px',
  margin: -1,
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  whiteSpace: 'nowrap',
  width: '1px',
});

function App() {
  return <div className={visuallyHidden}>I am invisible</div>;
}
```

The call to the `css` function is replaced with a unique string that represents the CSS class name for the generated styles.

Use a callback function to access [theme](#theming) values as shown below:

```js
const title = css(({ theme }) => ({
  color: theme.colors.primary,
  fontSize: theme.spacing.unit * 4,
  fontFamily: theme.typography.fontFamily,
}));
```

### Creating components

Use the `styled` API to create a component by passing styles at the end, as shown below:

```js
import { styled } from '@pigment-css/react';

const Heading = styled('div')({
  fontSize: '4rem',
  fontWeight: 'bold',
  padding: '10px 0px',
});

function App() {
  return <Heading>Hello</Heading>;
}
```

This usage should be familiar if you've worked with Emotion or styled-components.
But Pigment¬†CSS differs from these runtime CSS-in-JS libraries in a few ways:

1. You never get direct access to props in your styled declarations. This is because prop values are only available at runtime, but the CSS is extracted at build time. See [Styling based on runtime values](#styling-based-on-runtime-values) for a workaround.
2. Your styles must be declarative and must account for all combinations of props that you want to style.
3. The theme lets you declare CSS tokens that become part of the CSS bundle after the build. Any other values and methods that it might have are only available during build time‚Äînot at runtime. This leads to smaller bundle sizes.

#### Styling based on props

> üí° This approach is recommended when the values of the props are known at build time (finite values).

Use the `variants` key to define styles for a combination of a component's props.

Each variant is an object with `props` and `style` keys.
The styles are applied when the component's props match the `props` object.

**Example 1** ‚Äì A button component with `small` and `large` sizes:

```jsx
const Button = styled('button')({
  border: 'none',
  padding: '0.75rem',
  // ...other base styles
  variants: [
    {
      props: { size: 'large' },
      style: { padding: '1rem' },
    },
    {
      props: { size: 'small' },
      style: { padding: '0.5rem' },
    },
  ],
});

<Button>Normal button</Button>; // padding: 0.75rem
<Button size="large">Large button</Button>; // padding: 1rem
<Button size="small">Small button</Button>; // padding: 0.5rem
```

**Example 2** ‚Äì A button component with variants and colors:

```jsx
const Button = styled('button')({
  border: 'none',
  padding: '0.75rem',
  // ...other base styles
  variants: [
    {
      props: { variant: 'contained', color: 'primary' },
      style: { backgroundColor: 'tomato', color: 'white' },
    },
  ],
});

// `backgroundColor: 'tomato', color: 'white'`
<Button variant="contained" color="primary">
  Submit
</Button>;
```

**Example 3** ‚Äì Conditionally applied styles:

The value of the `props` can be a function that returns a boolean.
If the function returns `true`, then the styles are applied.

```jsx
const Button = styled('button')({
  border: 'none',
  padding: '0.75rem',
  // ...other base styles
  variants: [
    {
      props: (props) => props.variant !== 'contained',
      style: { backgroundColor: 'transparent' },
    },
  ],
});
```

Note that the `props` function doesn't work if it's inside another closure‚Äîfor example, this won't work inside an `array.map`:

```jsx
const Button = styled('button')({
  border: 'none',
  padding: '0.75rem',
  // ...other base styles
  variants: ['red', 'blue', 'green'].map((item) => ({
    props: (props) => {
      // ‚ùå Cannot access `item` in this closure
      return props.color === item && !props.disabled;
    },
    style: { backgroundColor: 'tomato' },
  })),
});
```

Instead you must use plain objects to define the variants:

```jsx
const Button = styled('button')({
  border: 'none',
  padding: '0.75rem',
  // ...other base styles
  variants: ['red', 'blue', 'green'].map((item) => ({
    props: { color: item, disabled: false },
    style: { backgroundColor: 'tomato' },
  })),
});
```

#### Styling based on runtime values

> üí° This approach is recommended when the values of the props are not known ahead of time or are potentially unlimited‚Äîfor example, styling based on the user's input.

There are two ways to apply styles based on runtime values.
Both involve using a CSS variable:

**Option 1** ‚Äì Declare a CSS variable directly in the styles and set its value using inline styles:

```jsx
const Heading = styled('h1')({
  color: 'var(--color)',
});

function Heading() {
  const [color, setColor] = React.useState('red');

  return <Heading style={{ '--color': color }} />;
}
```

**Option 2** ‚Äì Use a callback function as a value to create a dynamic style for the specific CSS property:

```jsx
const Heading = styled('h1')({
  color: ({ isError }) => (isError ? 'red' : 'black'),
});
```

Pigment¬†CSS replaces the callback with a CSS variable and injects the value through inline styles.
This makes it possible to create a static CSS file while still allowing for dynamic styles.

```css
.Heading_class_akjsdfb {
  color: var(--Heading_class_akjsdfb-0);
}
```

```jsx
<h1
  style={{
    '--Heading_class_akjsdfb-0': ({ isError }) => (isError ? 'red' : 'black'),
  }}
>
  Hello
</h1>
```

#### Styled component as a CSS selector

All of the components that you create are also available as CSS selectors.
For example, for the `Heading` component described in the previous section, you can target that component inside another styled component like this:

```jsx
const Wrapper = styled.div({
  [`& ${Heading}`]: {
    color: 'blue',
  },
});
```

This enables you to override the default `color` of the `Heading` component rendered inside the `Wrapper`:

```tsx
<Wrapper>
  <Heading>Hello</Heading>
</Wrapper>
```

You can also export any styled component you create and use it as the base for additional components:

```jsx
const ExtraHeading = styled(Heading)({
  // ... overridden styled
});
```

#### Media and container queries

Pigment¬†CSS APIs have built-in support for writing media queries and container queries.
Use the `@media` and `@container` keys to define styles for different screen and container sizes.

```jsx
import { css, styled } from '@pigment-css/react';

const styles = css({
  fontSize: '2rem',
  '@media (min-width: 768px)': {
    fontSize: '3rem',
  },
  '@container (max-width: 768px)': {
    fontSize: '1.5rem',
  },
});

const Heading = styled('h1')({
  fontSize: '2rem',
  '@media (min-width: 768px)': {
    fontSize: '3rem',
  },
  '@container (max-width: 768px)': {
    fontSize: '1.5rem',
  },
});
```

> üí° Pigment¬†CSS uses Emotion behind the scenes for turning tagged templates and objects into CSS strings.

#### Typing props

When using TypeScript, add the props typing before the styles to enable type-checking:

```tsx
const Heading = styled('h1')<{ isError?: boolean }>({
  color: ({ isError }) => (isError ? 'red' : 'black'),
});
```

### Creating animation keyframes

Use the `keyframes` API to create reusable [animation keyframes](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes).
For example, the snippet below creates a fade-in effect:

```js
import { keyframes } from '@pigment-css/react';

const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

function KeyFramesExample() {
  return <div style={{ animation: `${fadeIn} 0.5s` }}>I fade into view</div>;
}
```

The call to the `keyframes` function is replaced with a unique string that represents the name of the CSS animation.
The `keyframes` function can also be used with `css` or `styled`, as shown below:

```js
import { css, styled, keyframes } from '@pigment-css/react';

const fadeIn = keyframes(...);

const Example2 = styled('div')({
  animation: `${fadeIn} 0.5s`,
});

function App() {
  return (
    <>
      <KeyFramesExamples />
      <div
        className={css`
          animation: ${fadeIn} 0.5s;
        `}
      />
    </>
  )
}
```

### Theming

> üí° The theme object is used at build time and does not exist in the final JavaScript bundle; this means that components created using the `styled` function are compatible with React Server Components.

Theming is an optional feature that lets you reuse values such as colors, spacing, and typography across your application.
The theme is a plain object that can take any structure, which is defined in your config file.

For example, in Next.js, you can define a theme in the `next.config.js` file like this:

```js
const { withPigment } = require('@pigment-css/nextjs-plugin');

module.exports = withPigment(
  {
    // ...other nextConfig
  },
  {
    theme: {
      colors: {
        primary: 'tomato',
        secondary: 'cyan',
      },
      spacing: {
        unit: 8,
      },
      typography: {
        fontFamily: 'Inter, sans-serif',
      },
      // ...additional keys and values as needed
    },
  },
);
```

#### Accessing theme values

You can use a callback with the `styled` and `css` APIs to access theme values:

```js
const Heading = styled('h1')(({ theme }) => ({
  color: theme.colors.primary,
  fontSize: theme.spacing.unit * 4,
  fontFamily: theme.typography.fontFamily,
}));
```

#### CSS variables support

Pigment¬†CSS can generate CSS variables from theme values when you wrap your theme with the `extendTheme` utility.
For example, this is what it would look like in a `next.config.js` file:

```js
const { withPigment, extendTheme } = require('@pigment-css/nextjs-plugin');

module.exports = withPigment(
  {
    // ...nextConfig
  },
  {
    theme: extendTheme({
      colors: {
        primary: 'tomato',
        secondary: 'cyan',
      },
      spacing: {
        unit: 8,
      },
      typography: {
        fontFamily: 'Inter, sans-serif',
      },
    }),
  },
);
```

The `extendTheme` utility goes through the theme and creates a `vars` object which represents the tokens that refer to CSS variables.

```jsx
const theme = extendTheme({
  colors: {
    primary: 'tomato',
    secondary: 'cyan',
  },
});

console.log(theme.colors.primary); // 'tomato'
console.log(theme.vars.colors.primary); // 'var(--colors-primary)'
```

#### Adding a prefix to CSS variables

You can add a prefix to the generated CSS variables by providing a `cssVarPrefix` option to the `extendTheme` utility:

```jsx
extendTheme({
  cssVarPrefix: 'pigment',
});
```

The generated CSS variables has the `pigment` prefix:

```css
:root {
  --pigment-colors-background: #f9f9f9;
  --pigment-colors-foreground: #121212;
}
```

#### Color schemes

Color-related tokens sometimes require multiple values to cover different color schemes in an app.
For example, the app might have light mode with a white background and a dark mode with a black background.

The `extendTheme` utility lets you define a theme with a special `colorSchemes` key to accommmodate this.
The structure of each color scheme must be a plain object with keys and values.
The snippet below shows how to create basic `light` and `dark` schemes:

```jsx
extendTheme({
  colorSchemes: {
    light: {
      colors: {
        background: '#f9f9f9',
        foreground: '#121212',
      },
    },
    dark: {
      colors: {
        background: '#212121',
        foreground: '#fff',
      },
    },
  },
});
```

#### Switching color schemes

By default, when `colorSchemes` is defined, Pigment¬†CSS uses the [`prefers-color-scheme`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme) media query to switch between color schemes based on the user's system settings.

But if you want to control the color scheme based on application logic‚Äîfor example, using a button to switch between light and dark mode‚Äîyou can customize the behavior by providing a `getSelector` function as shown below:

```diff
  extendTheme({
    colorSchemes: {
      light: { ... },
      dark: { ... },
    },
+   getSelector: (colorScheme) => colorScheme ? `.theme-${colorScheme}` : ':root',
  });
```

Note that you'll also need to add the logic to the button‚Äîhere's an example of how to do it:

```jsx
function App() {
  return (
    <button
      onClick={() => {
        document.documentElement.classList.toggle('theme-dark');
      }}
    >
      Toggle color scheme
    </button>
  );
}
```

#### Styling based on color scheme

The `extendTheme` utility attaches a function called `applyStyles` to the theme object.
This function receives a color scheme as the first argument followed by a style object, and returns a proper CSS selector based on the theme configuration.

Here's an example implementation:

```jsx
const Heading = styled('h1')(({ theme }) => ({
  color: theme.colors.primary,
  fontSize: theme.spacing.unit * 4,
  fontFamily: theme.typography.fontFamily,
  ...theme.applyStyles('dark', {
    color: theme.colors.primaryLight,
  }),
}));
```

#### TypeScript

When using TypeScript, you must augment the theme type to enable type-checking:

```ts
// any file that is included in your tsconfig.json
import type { ExtendTheme } from '@pigment-css/react/theme';

declare module '@pigment-css/react/theme' {
  interface ThemeTokens {
    // the structure of your theme
  }

  interface ThemeArgs {
    theme: ExtendTheme<{
      colorScheme: 'light' | 'dark';
      tokens: ThemeTokens;
    }>;
  }
}
```

## How-to guides

### Coming from Emotion or styled-components

Emotion and styled-components are runtime CSS-in-JS libraries: What you write in your styles is what you get in the final bundle.
This means styles can be dynamic, but that comes with corresponding trade-offs in terms of bundle size and performance overhead.

By contrast, Pigment¬†CSS extracts CSS at build time and replaces the JavaScript code with hashed class names and CSS variables.
This means it needs to know all of the styles to be extracted ahead of time, so there are some rules and limitations to be aware of when using JavaScript callbacks or variables with the Pigment¬†CSS APIs.

Here are some common patterns from Emotion and styled-components, and how to implement them with Pigment¬†CSS:

#### Fixed set of styles

In Emotion or styled-components, you can use props to create styles conditionally:

```js
const Flex = styled('div')((props) => ({
  display: 'flex',
  ...(props.vertical // ‚ùå Pigment¬†CSS will throw an error
    ? {
        flexDirection: 'column',
        paddingBlock: '1rem',
      }
    : {
        paddingInline: '1rem',
      }),
}));
```

But in Pigment¬†CSS, you need to define all of the styles ahead of time using the `variants` key:

```js
const Flex = styled('div')((props) => ({
  display: 'flex',
  variants: [
    {
      props: { vertical: true },
      style: {
        flexDirection: 'column',
        paddingBlock: '1rem',
      },
    },
    {
      props: { vertical: false },
      style: {
        paddingInline: '1rem',
      },
    },
  ],
}));
```

> üí° Keep in mind that the `variants` key is for fixed values of props‚Äîfor example, a component's colors, sizes, and states.

#### Programatically generated styles

Because Emotion and styled-components generate styles at runtime, those styles can potentially be different between renders and instances.
For example, the calculated values in the code snippet below would be different each time the component renders:

```js
function randomBetween(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function generateBubbleVars() {
  return `
    --x: ${randomBetween(10, 90)}%;
    --y: ${randomBetween(15, 85)}%;
  `;
}

function App() {
  return (
    <div>
      {[...Array(10)].map((_, index) => (
        <div
          key={index}
          className={css`
            ${generateBubbleVars()}
          `}
        />
      ))}
    </div>
  );
}
```

But if you wrote the code above with Pigment¬†CSS, all instances would have the same styles that would never change between renders because they're extracted at build time.

To implement programmatically generated styles with Pigment CSS, you must move the dynamic logic to props and pass the value to CSS variables instead.
The snippet below leads to values that change between renders and instances as intended in the prior example:

```js
function randomBetween(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

const Bubble = styled('div')({
  '--x': (props) => props.x,
  '--y': (props) => props.y,
});

function App() {
  return (
    <div>
      {[...Array(10)].map((_, index) => (
        <Bubble key={index} x={`${randomBetween(10, 90)}%`} y={`${randomBetween(15, 85)}%`} />
      ))}
    </div>
  );
}
```
