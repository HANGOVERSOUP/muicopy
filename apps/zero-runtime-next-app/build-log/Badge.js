import "/Users/siriwatknp/Personal-Repos/material-ui/packages/zero-next-plugin/zero-virtual.css?%7B%22filename%22%3A%2250f7n.zero.css%22%2C%22source%22%3A%22.BadgeRoot_bdxyzxj%7Bposition%3Arelative%3Bdisplay%3Ainline-flex%3Bvertical-align%3Amiddle%3Bflex-shrink%3A0%3B%7D%5Cn.BadgeBadge_b14y6z35%7Bdisplay%3Aflex%3Bflex-direction%3Arow%3Bflex-wrap%3Awrap%3Bjustify-content%3Acenter%3Balign-content%3Acenter%3Balign-items%3Acenter%3Bposition%3Aabsolute%3Bbox-sizing%3Aborder-box%3Bfont-family%3A%5C%22Roboto%5C%22%2C%5C%22Helvetica%5C%22%2C%5C%22Arial%5C%22%2Csans-serif%3Bfont-weight%3A500%3Bfont-size%3A0.75rem%3Bmin-width%3A20px%3Bline-height%3A1%3Bpadding%3A0%206px%3Bheight%3A20px%3Bborder-radius%3A10px%3Bz-index%3A1%3Btransition%3Atransform%20225ms%20cubic-bezier(0.4%2C%200%2C%200.2%2C%201)%200ms%3B%7D%5Cn.BadgeBadge_b14y6z35-variant%7Bbackground-color%3Avar(--app-palette-primary-main%2C%20%231976d2)%3Bcolor%3Avar(--app-palette-primary-contrastText%2C%20%23fff)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-1%7Bbackground-color%3Avar(--app-palette-secondary-main%2C%20%239c27b0)%3Bcolor%3Avar(--app-palette-secondary-contrastText%2C%20%23fff)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-2%7Bbackground-color%3Avar(--app-palette-error-main%2C%20%23d32f2f)%3Bcolor%3Avar(--app-palette-error-contrastText%2C%20%23fff)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-3%7Bbackground-color%3Avar(--app-palette-warning-main%2C%20%23ed6c02)%3Bcolor%3Avar(--app-palette-warning-contrastText%2C%20%23fff)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-4%7Bbackground-color%3Avar(--app-palette-info-main%2C%20%230288d1)%3Bcolor%3Avar(--app-palette-info-contrastText%2C%20%23fff)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-5%7Bbackground-color%3Avar(--app-palette-success-main%2C%20%232e7d32)%3Bcolor%3Avar(--app-palette-success-contrastText%2C%20%23fff)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-6%7Bborder-radius%3A4px%3Bheight%3A8px%3Bmin-width%3A8px%3Bpadding%3A0%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-7%7Btop%3A0%3Bright%3A0%3Btransform%3Ascale(1)%20translate(50%25%2C%20-50%25)%3Btransform-origin%3A100%25%200%25%3B%7D.BadgeBadge_b14y6z35-variant-7.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(50%25%2C%20-50%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-8%7Bbottom%3A0%3Bright%3A0%3Btransform%3Ascale(1)%20translate(50%25%2C%2050%25)%3Btransform-origin%3A100%25%20100%25%3B%7D.BadgeBadge_b14y6z35-variant-8.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(50%25%2C%2050%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-9%7Btop%3A0%3Bleft%3A0%3Btransform%3Ascale(1)%20translate(-50%25%2C%20-50%25)%3Btransform-origin%3A0%25%200%25%3B%7D.BadgeBadge_b14y6z35-variant-9.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(-50%25%2C%20-50%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-10%7Bbottom%3A0%3Bleft%3A0%3Btransform%3Ascale(1)%20translate(-50%25%2C%2050%25)%3Btransform-origin%3A0%25%20100%25%3B%7D.BadgeBadge_b14y6z35-variant-10.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(-50%25%2C%2050%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-11%7Btop%3A14%25%3Bright%3A14%25%3Btransform%3Ascale(1)%20translate(50%25%2C%20-50%25)%3Btransform-origin%3A100%25%200%25%3B%7D.BadgeBadge_b14y6z35-variant-11.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(50%25%2C%20-50%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-12%7Bbottom%3A14%25%3Bright%3A14%25%3Btransform%3Ascale(1)%20translate(50%25%2C%2050%25)%3Btransform-origin%3A100%25%20100%25%3B%7D.BadgeBadge_b14y6z35-variant-12.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(50%25%2C%2050%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-13%7Btop%3A14%25%3Bleft%3A14%25%3Btransform%3Ascale(1)%20translate(-50%25%2C%20-50%25)%3Btransform-origin%3A0%25%200%25%3B%7D.BadgeBadge_b14y6z35-variant-13.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(-50%25%2C%20-50%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-14%7Bbottom%3A14%25%3Bleft%3A14%25%3Btransform%3Ascale(1)%20translate(-50%25%2C%2050%25)%3Btransform-origin%3A0%25%20100%25%3B%7D.BadgeBadge_b14y6z35-variant-14.MuiBadge-invisible%7Btransform%3Ascale(0)%20translate(-50%25%2C%2050%25)%3B%7D%5Cn.BadgeBadge_b14y6z35-variant-15%7Btransition%3Atransform%20195ms%20cubic-bezier(0.4%2C%200%2C%200.2%2C%201)%200ms%3B%7D%5Cn%2F*%23%20sourceMappingURL%3Ddata%3Aapplication%2Fjson%3Bbase64%2CeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zaXJpd2F0a25wL1BlcnNvbmFsLVJlcG9zL21hdGVyaWFsLXVpL3BhY2thZ2VzL211aS1tYXRlcmlhbC9idWlsZC9CYWRnZS9CYWRnZS5qcyJdLCJuYW1lcyI6WyIuQmFkZ2VSb290X2JkeHl6eGoiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNSIsIi5CYWRnZUJhZGdlX2IxNHk2ejM1LXZhcmlhbnQiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTEiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTIiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTMiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTQiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTUiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTYiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTciLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTgiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTkiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTEwIiwiLkJhZGdlQmFkZ2VfYjE0eTZ6MzUtdmFyaWFudC0xMSIsIi5CYWRnZUJhZGdlX2IxNHk2ejM1LXZhcmlhbnQtMTIiLCIuQmFkZ2VCYWRnZV9iMTR5NnozNS12YXJpYW50LTEzIiwiLkJhZGdlQmFkZ2VfYjE0eTZ6MzUtdmFyaWFudC0xNCIsIi5CYWRnZUJhZGdlX2IxNHk2ejM1LXZhcmlhbnQtMTUiXSwibWFwcGluZ3MiOiJBQWtDa0JBO0FBV0NDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDIiwiZmlsZSI6Ii9Vc2Vycy9zaXJpd2F0a25wL1BlcnNvbmFsLVJlcG9zL21hdGVyaWFsLXVpL3BhY2thZ2VzL211aS1tYXRlcmlhbC9idWlsZC9CYWRnZS9CYWRnZS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBfX25leHRfaW50ZXJuYWxfY2xpZW50X2VudHJ5X2RvX25vdF91c2VfXyBkZWZhdWx0IGF1dG8gKi92YXIgX3MgPSAkUmVmcmVzaFNpZyQoKTtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5jb25zdCBfZXhjbHVkZWQgPSBbXCJhbmNob3JPcmlnaW5cIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc2VzXCIsIFwiY29tcG9uZW50XCIsIFwiY29tcG9uZW50c1wiLCBcImNvbXBvbmVudHNQcm9wc1wiLCBcImNoaWxkcmVuXCIsIFwib3ZlcmxhcFwiLCBcImNvbG9yXCIsIFwiaW52aXNpYmxlXCIsIFwibWF4XCIsIFwiYmFkZ2VDb250ZW50XCIsIFwic2xvdHNcIiwgXCJzbG90UHJvcHNcIiwgXCJzaG93WmVyb1wiLCBcInZhcmlhbnRcIl07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyB1c2VQcmV2aW91c1Byb3BzIH0gZnJvbSBcIkBtdWkvdXRpbHNcIjtcbmltcG9ydCB7IHVuc3RhYmxlX2NvbXBvc2VDbGFzc2VzIGFzIGNvbXBvc2VDbGFzc2VzIH0gZnJvbSBcIkBtdWkvYmFzZS9jb21wb3NlQ2xhc3Nlc1wiO1xuaW1wb3J0IHsgdXNlQmFkZ2UgfSBmcm9tIFwiQG11aS9iYXNlL3VzZUJhZGdlXCI7XG5pbXBvcnQgeyB1c2VTbG90UHJvcHMgfSBmcm9tIFwiQG11aS9iYXNlXCI7XG5pbXBvcnQgeyBzdHlsZWQsIGNyZWF0ZVVzZVRoZW1lUHJvcHMgfSBmcm9tIFwiLi4vemVyby1zdHlsZWRcIjtcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gXCIuLi91dGlscy9jYXBpdGFsaXplXCI7XG5pbXBvcnQgYmFkZ2VDbGFzc2VzLCB7IGdldEJhZGdlVXRpbGl0eUNsYXNzIH0gZnJvbSBcIi4vYmFkZ2VDbGFzc2VzXCI7XG5pbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgUkFESVVTX1NUQU5EQVJEID0gMTA7XG5jb25zdCBSQURJVVNfRE9UID0gNDtcbmNvbnN0IHVzZVRoZW1lUHJvcHMgPSBjcmVhdGVVc2VUaGVtZVByb3BzKFwiTXVpQmFkZ2VcIik7XG5jb25zdCB1c2VVdGlsaXR5Q2xhc3NlcyA9IG93bmVyU3RhdGUgPT4ge1xuICBjb25zdCB7XG4gICAgY29sb3IsXG4gICAgYW5jaG9yT3JpZ2luLFxuICAgIGludmlzaWJsZSxcbiAgICBvdmVybGFwLFxuICAgIHZhcmlhbnQsXG4gICAgY2xhc3NlcyA9IHt9XG4gIH0gPSBvd25lclN0YXRlO1xuICBjb25zdCBzbG90cyA9IHtcbiAgICByb290OiBbXCJyb290XCJdLFxuICAgIGJhZGdlOiBbXCJiYWRnZVwiLCB2YXJpYW50LCBpbnZpc2libGUgJiYgXCJpbnZpc2libGVcIiwgYGFuY2hvck9yaWdpbiR7Y2FwaXRhbGl6ZShhbmNob3JPcmlnaW4udmVydGljYWwpfSR7Y2FwaXRhbGl6ZShhbmNob3JPcmlnaW4uaG9yaXpvbnRhbCl9YCwgYGFuY2hvck9yaWdpbiR7Y2FwaXRhbGl6ZShhbmNob3JPcmlnaW4udmVydGljYWwpfSR7Y2FwaXRhbGl6ZShhbmNob3JPcmlnaW4uaG9yaXpvbnRhbCl9JHtjYXBpdGFsaXplKG92ZXJsYXApfWAsIGBvdmVybGFwJHtjYXBpdGFsaXplKG92ZXJsYXApfWAsIGNvbG9yICE9PSBcImRlZmF1bHRcIiAmJiBgY29sb3Ike2NhcGl0YWxpemUoY29sb3IpfWBdXG4gIH07XG4gIHJldHVybiBjb21wb3NlQ2xhc3NlcyhzbG90cywgZ2V0QmFkZ2VVdGlsaXR5Q2xhc3MsIGNsYXNzZXMpO1xufTtcbmNvbnN0IEJhZGdlUm9vdCA9IHN0eWxlZChcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aUJhZGdlXCIsXG4gIHNsb3Q6IFwiUm9vdFwiLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKHByb3BzLCBzdHlsZXMpID0%2BIHN0eWxlcy5yb290XG59KSh7XG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIGRpc3BsYXk6IFwiaW5saW5lLWZsZXhcIixcbiAgLy8gRm9yIGNvcnJlY3QgYWxpZ25tZW50IHdpdGggdGhlIHRleHQuXG4gIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gIGZsZXhTaHJpbms6IDBcbn0pO1xuY29uc3QgQmFkZ2VCYWRnZSA9IHN0eWxlZChcInNwYW5cIiwge1xuICBuYW1lOiBcIk11aUJhZGdlXCIsXG4gIHNsb3Q6IFwiQmFkZ2VcIixcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChwcm9wcywgc3R5bGVzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZVxuICAgIH0gPSBwcm9wcztcbiAgICByZXR1cm4gW3N0eWxlcy5iYWRnZSwgc3R5bGVzW293bmVyU3RhdGUudmFyaWFudF0sIHN0eWxlc1tgYW5jaG9yT3JpZ2luJHtjYXBpdGFsaXplKG93bmVyU3RhdGUuYW5jaG9yT3JpZ2luLnZlcnRpY2FsKX0ke2NhcGl0YWxpemUob3duZXJTdGF0ZS5hbmNob3JPcmlnaW4uaG9yaXpvbnRhbCl9JHtjYXBpdGFsaXplKG93bmVyU3RhdGUub3ZlcmxhcCl9YF0sIG93bmVyU3RhdGUuY29sb3IgIT09IFwiZGVmYXVsdFwiICYmIHN0eWxlc1tgY29sb3Ike2NhcGl0YWxpemUob3duZXJTdGF0ZS5jb2xvcil9YF0sIG93bmVyU3RhdGUuaW52aXNpYmxlICYmIHN0eWxlcy5pbnZpc2libGVdO1xuICB9XG59KSgoe1xuICB0aGVtZVxufSkgPT4ge1xuICB2YXIgX3RoZW1lJHZhcnM7XG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJyb3dcIixcbiAgICBmbGV4V3JhcDogXCJ3cmFwXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgYWxpZ25Db250ZW50OiBcImNlbnRlclwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxMiksXG4gICAgbWluV2lkdGg6IFJBRElVU19TVEFOREFSRCAqIDIsXG4gICAgbGluZUhlaWdodDogMSxcbiAgICBwYWRkaW5nOiBcIjAgNnB4XCIsXG4gICAgaGVpZ2h0OiBSQURJVVNfU1RBTkRBUkQgKiAyLFxuICAgIGJvcmRlclJhZGl1czogUkFESVVTX1NUQU5EQVJELFxuICAgIHpJbmRleDogMSxcbiAgICAvLyBSZW5kZXIgdGhlIGJhZGdlIG9uIHRvcCBvZiBwb3RlbnRpYWwgcmlwcGxlcy5cbiAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoXCJ0cmFuc2Zvcm1cIiwge1xuICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0LFxuICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLmVudGVyaW5nU2NyZWVuXG4gICAgfSksXG4gICAgdmFyaWFudHM6IFsuLi5PYmplY3Qua2V5cygoKF90aGVtZSR2YXJzID0gdGhlbWUudmFycykgIT0gbnVsbCA%2FIF90aGVtZSR2YXJzIDogdGhlbWUpLnBhbGV0dGUpLmZpbHRlcihrZXkgPT4ge1xuICAgICAgdmFyIF90aGVtZSR2YXJzMiwgX3RoZW1lJHZhcnMzO1xuICAgICAgcmV0dXJuICgoX3RoZW1lJHZhcnMyID0gdGhlbWUudmFycykgIT0gbnVsbCA%2FIF90aGVtZSR2YXJzMiA6IHRoZW1lKS5wYWxldHRlW2tleV0ubWFpbiAmJiAoKF90aGVtZSR2YXJzMyA9IHRoZW1lLnZhcnMpICE9IG51bGwgPyBfdGhlbWUkdmFyczMgOiB0aGVtZSkucGFsZXR0ZVtrZXldLmNvbnRyYXN0VGV4dDtcbiAgICB9KS5tYXAoY29sb3IgPT4gKHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAodGhlbWUudmFycyB8fCB0aGVtZSkucGFsZXR0ZVtjb2xvcl0ubWFpbixcbiAgICAgICAgY29sb3I6ICh0aGVtZS52YXJzIHx8IHRoZW1lKS5wYWxldHRlW2NvbG9yXS5jb250cmFzdFRleHRcbiAgICAgIH1cbiAgICB9KSksIHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwiZG90XCJcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBib3JkZXJSYWRpdXM6IFJBRElVU19ET1QsXG4gICAgICAgIGhlaWdodDogUkFESVVTX0RPVCAqIDIsXG4gICAgICAgIG1pbldpZHRoOiBSQURJVVNfRE9UICogMixcbiAgICAgICAgcGFkZGluZzogMFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHByb3BzOiAoe1xuICAgICAgICBvd25lclN0YXRlXG4gICAgICB9KSA9PiBvd25lclN0YXRlLmFuY2hvck9yaWdpbi52ZXJ0aWNhbCA9PT0gXCJ0b3BcIiAmJiBvd25lclN0YXRlLmFuY2hvck9yaWdpbi5ob3Jpem9udGFsID09PSBcInJpZ2h0XCIgJiYgb3duZXJTdGF0ZS5vdmVybGFwID09PSBcInJlY3Rhbmd1bGFyXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSkgdHJhbnNsYXRlKDUwJSwgLTUwJSlcIixcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjEwMCUgMCVcIixcbiAgICAgICAgW2AmLiR7YmFkZ2VDbGFzc2VzLmludmlzaWJsZX1gXToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwKSB0cmFuc2xhdGUoNTAlLCAtNTAlKVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZVxuICAgICAgfSkgPT4gb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4udmVydGljYWwgPT09IFwiYm90dG9tXCIgJiYgb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4uaG9yaXpvbnRhbCA9PT0gXCJyaWdodFwiICYmIG93bmVyU3RhdGUub3ZlcmxhcCA9PT0gXCJyZWN0YW5ndWxhclwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpIHRyYW5zbGF0ZSg1MCUsIDUwJSlcIixcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjEwMCUgMTAwJVwiLFxuICAgICAgICBbYCYuJHtiYWRnZUNsYXNzZXMuaW52aXNpYmxlfWBdOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDApIHRyYW5zbGF0ZSg1MCUsIDUwJSlcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6ICh7XG4gICAgICAgIG93bmVyU3RhdGVcbiAgICAgIH0pID0%2BIG93bmVyU3RhdGUuYW5jaG9yT3JpZ2luLnZlcnRpY2FsID09PSBcInRvcFwiICYmIG93bmVyU3RhdGUuYW5jaG9yT3JpZ2luLmhvcml6b250YWwgPT09IFwibGVmdFwiICYmIG93bmVyU3RhdGUub3ZlcmxhcCA9PT0gXCJyZWN0YW5ndWxhclwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsIC01MCUpXCIsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCIwJSAwJVwiLFxuICAgICAgICBbYCYuJHtiYWRnZUNsYXNzZXMuaW52aXNpYmxlfWBdOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDApIHRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZVxuICAgICAgfSkgPT4gb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4udmVydGljYWwgPT09IFwiYm90dG9tXCIgJiYgb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4uaG9yaXpvbnRhbCA9PT0gXCJsZWZ0XCIgJiYgb3duZXJTdGF0ZS5vdmVybGFwID09PSBcInJlY3Rhbmd1bGFyXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKSB0cmFuc2xhdGUoLTUwJSwgNTAlKVwiLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMCUgMTAwJVwiLFxuICAgICAgICBbYCYuJHtiYWRnZUNsYXNzZXMuaW52aXNpYmxlfWBdOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDApIHRyYW5zbGF0ZSgtNTAlLCA1MCUpXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHByb3BzOiAoe1xuICAgICAgICBvd25lclN0YXRlXG4gICAgICB9KSA9PiBvd25lclN0YXRlLmFuY2hvck9yaWdpbi52ZXJ0aWNhbCA9PT0gXCJ0b3BcIiAmJiBvd25lclN0YXRlLmFuY2hvck9yaWdpbi5ob3Jpem9udGFsID09PSBcInJpZ2h0XCIgJiYgb3duZXJTdGF0ZS5vdmVybGFwID09PSBcImNpcmN1bGFyXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICB0b3A6IFwiMTQlXCIsXG4gICAgICAgIHJpZ2h0OiBcIjE0JVwiLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSkgdHJhbnNsYXRlKDUwJSwgLTUwJSlcIixcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjEwMCUgMCVcIixcbiAgICAgICAgW2AmLiR7YmFkZ2VDbGFzc2VzLmludmlzaWJsZX1gXToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwKSB0cmFuc2xhdGUoNTAlLCAtNTAlKVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZVxuICAgICAgfSkgPT4gb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4udmVydGljYWwgPT09IFwiYm90dG9tXCIgJiYgb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4uaG9yaXpvbnRhbCA9PT0gXCJyaWdodFwiICYmIG93bmVyU3RhdGUub3ZlcmxhcCA9PT0gXCJjaXJjdWxhclwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm90dG9tOiBcIjE0JVwiLFxuICAgICAgICByaWdodDogXCIxNCVcIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpIHRyYW5zbGF0ZSg1MCUsIDUwJSlcIixcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjEwMCUgMTAwJVwiLFxuICAgICAgICBbYCYuJHtiYWRnZUNsYXNzZXMuaW52aXNpYmxlfWBdOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDApIHRyYW5zbGF0ZSg1MCUsIDUwJSlcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcHJvcHM6ICh7XG4gICAgICAgIG93bmVyU3RhdGVcbiAgICAgIH0pID0%2BIG93bmVyU3RhdGUuYW5jaG9yT3JpZ2luLnZlcnRpY2FsID09PSBcInRvcFwiICYmIG93bmVyU3RhdGUuYW5jaG9yT3JpZ2luLmhvcml6b250YWwgPT09IFwibGVmdFwiICYmIG93bmVyU3RhdGUub3ZlcmxhcCA9PT0gXCJjaXJjdWxhclwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG9wOiBcIjE0JVwiLFxuICAgICAgICBsZWZ0OiBcIjE0JVwiLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsIC01MCUpXCIsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCIwJSAwJVwiLFxuICAgICAgICBbYCYuJHtiYWRnZUNsYXNzZXMuaW52aXNpYmxlfWBdOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDApIHRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwcm9wczogKHtcbiAgICAgICAgb3duZXJTdGF0ZVxuICAgICAgfSkgPT4gb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4udmVydGljYWwgPT09IFwiYm90dG9tXCIgJiYgb3duZXJTdGF0ZS5hbmNob3JPcmlnaW4uaG9yaXpvbnRhbCA9PT0gXCJsZWZ0XCIgJiYgb3duZXJTdGF0ZS5vdmVybGFwID09PSBcImNpcmN1bGFyXCIsXG4gICAgICBzdHlsZToge1xuICAgICAgICBib3R0b206IFwiMTQlXCIsXG4gICAgICAgIGxlZnQ6IFwiMTQlXCIsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKSB0cmFuc2xhdGUoLTUwJSwgNTAlKVwiLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMCUgMTAwJVwiLFxuICAgICAgICBbYCYuJHtiYWRnZUNsYXNzZXMuaW52aXNpYmxlfWBdOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDApIHRyYW5zbGF0ZSgtNTAlLCA1MCUpXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGludmlzaWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZShcInRyYW5zZm9ybVwiLCB7XG4gICAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5sZWF2aW5nU2NyZWVuXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfV1cbiAgfTtcbn0pO1xuY29uc3QgQmFkZ2UgPSAvKiNfX1BVUkVfXyovX3MoUmVhY3QuZm9yd2FyZFJlZihfYyA9IF9zKGZ1bmN0aW9uIEJhZGdlKGluUHJvcHMsIHJlZikge1xuICBfcygpO1xuICB2YXIgX3JlZiwgX3Nsb3RzJHJvb3QsIF9yZWYyLCBfc2xvdHMkYmFkZ2UsIF9zbG90UHJvcHMkcm9vdCwgX3Nsb3RQcm9wcyRiYWRnZTtcbiAgY29uc3QgcHJvcHMgPSB1c2VUaGVtZVByb3BzKHtcbiAgICBwcm9wczogaW5Qcm9wcyxcbiAgICBuYW1lOiBcIk11aUJhZGdlXCJcbiAgfSk7XG4gIGNvbnN0IHtcbiAgICAgIGFuY2hvck9yaWdpbjogYW5jaG9yT3JpZ2luUHJvcCA9IHtcbiAgICAgICAgdmVydGljYWw6IFwidG9wXCIsXG4gICAgICAgIGhvcml6b250YWw6IFwicmlnaHRcIlxuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIGNvbXBvbmVudHMgPSB7fSxcbiAgICAgIGNvbXBvbmVudHNQcm9wcyA9IHt9LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBvdmVybGFwOiBvdmVybGFwUHJvcCA9IFwicmVjdGFuZ3VsYXJcIixcbiAgICAgIGNvbG9yOiBjb2xvclByb3AgPSBcImRlZmF1bHRcIixcbiAgICAgIGludmlzaWJsZTogaW52aXNpYmxlUHJvcCA9IGZhbHNlLFxuICAgICAgbWF4OiBtYXhQcm9wID0gOTksXG4gICAgICBiYWRnZUNvbnRlbnQ6IGJhZGdlQ29udGVudFByb3AsXG4gICAgICBzbG90cyxcbiAgICAgIHNsb3RQcm9wcyxcbiAgICAgIHNob3daZXJvID0gZmFsc2UsXG4gICAgICB2YXJpYW50OiB2YXJpYW50UHJvcCA9IFwic3RhbmRhcmRcIlxuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuICBjb25zdCB7XG4gICAgYmFkZ2VDb250ZW50LFxuICAgIGludmlzaWJsZTogaW52aXNpYmxlRnJvbUhvb2ssXG4gICAgbWF4LFxuICAgIGRpc3BsYXlWYWx1ZTogZGlzcGxheVZhbHVlRnJvbUhvb2tcbiAgfSA9IHVzZUJhZGdlKHtcbiAgICBtYXg6IG1heFByb3AsXG4gICAgaW52aXNpYmxlOiBpbnZpc2libGVQcm9wLFxuICAgIGJhZGdlQ29udGVudDogYmFkZ2VDb250ZW50UHJvcCxcbiAgICBzaG93WmVyb1xuICB9KTtcbiAgY29uc3QgcHJldlByb3BzID0gdXNlUHJldmlvdXNQcm9wcyh7XG4gICAgYW5jaG9yT3JpZ2luOiBhbmNob3JPcmlnaW5Qcm9wLFxuICAgIGNvbG9yOiBjb2xvclByb3AsXG4gICAgb3ZlcmxhcDogb3ZlcmxhcFByb3AsXG4gICAgdmFyaWFudDogdmFyaWFudFByb3AsXG4gICAgYmFkZ2VDb250ZW50OiBiYWRnZUNvbnRlbnRQcm9wXG4gIH0pO1xuICBjb25zdCBpbnZpc2libGUgPSBpbnZpc2libGVGcm9tSG9vayB8fCBiYWRnZUNvbnRlbnQgPT0gbnVsbCAmJiB2YXJpYW50UHJvcCAhPT0gXCJkb3RcIjtcbiAgY29uc3Qge1xuICAgIGNvbG9yID0gY29sb3JQcm9wLFxuICAgIG92ZXJsYXAgPSBvdmVybGFwUHJvcCxcbiAgICBhbmNob3JPcmlnaW4gPSBhbmNob3JPcmlnaW5Qcm9wLFxuICAgIHZhcmlhbnQgPSB2YXJpYW50UHJvcFxuICB9ID0gaW52aXNpYmxlID8gcHJldlByb3BzIDogcHJvcHM7XG4gIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IHZhcmlhbnQgIT09IFwiZG90XCIgPyBkaXNwbGF5VmFsdWVGcm9tSG9vayA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3duZXJTdGF0ZSA9IF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGJhZGdlQ29udGVudCxcbiAgICBpbnZpc2libGUsXG4gICAgbWF4LFxuICAgIGRpc3BsYXlWYWx1ZSxcbiAgICBzaG93WmVybyxcbiAgICBhbmNob3JPcmlnaW4sXG4gICAgY29sb3IsXG4gICAgb3ZlcmxhcCxcbiAgICB2YXJpYW50XG4gIH0pO1xuICBjb25zdCBjbGFzc2VzID0gdXNlVXRpbGl0eUNsYXNzZXMob3duZXJTdGF0ZSk7XG4gIC8vIHN1cHBvcnQgYm90aCBgc2xvdHNgIGFuZCBgY29tcG9uZW50c2AgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgUm9vdFNsb3QgPSAoX3JlZiA9IChfc2xvdHMkcm9vdCA9IHNsb3RzID09IG51bGwgPyB2b2lkIDAgOiBzbG90cy5yb290KSAhPSBudWxsID8gX3Nsb3RzJHJvb3QgOiBjb21wb25lbnRzLlJvb3QpICE9IG51bGwgPyBfcmVmIDogQmFkZ2VSb290O1xuICBjb25zdCBCYWRnZVNsb3QgPSAoX3JlZjIgPSAoX3Nsb3RzJGJhZGdlID0gc2xvdHMgPT0gbnVsbCA%2FIHZvaWQgMCA6IHNsb3RzLmJhZGdlKSAhPSBudWxsID8gX3Nsb3RzJGJhZGdlIDogY29tcG9uZW50cy5CYWRnZSkgIT0gbnVsbCA%2FIF9yZWYyIDogQmFkZ2VCYWRnZTtcbiAgY29uc3Qgcm9vdFNsb3RQcm9wcyA9IChfc2xvdFByb3BzJHJvb3QgPSBzbG90UHJvcHMgPT0gbnVsbCA%2FIHZvaWQgMCA6IHNsb3RQcm9wcy5yb290KSAhPSBudWxsID8gX3Nsb3RQcm9wcyRyb290IDogY29tcG9uZW50c1Byb3BzLnJvb3Q7XG4gIGNvbnN0IGJhZGdlU2xvdFByb3BzID0gKF9zbG90UHJvcHMkYmFkZ2UgPSBzbG90UHJvcHMgPT0gbnVsbCA%2FIHZvaWQgMCA6IHNsb3RQcm9wcy5iYWRnZSkgIT0gbnVsbCA%2FIF9zbG90UHJvcHMkYmFkZ2UgOiBjb21wb25lbnRzUHJvcHMuYmFkZ2U7XG4gIGNvbnN0IHJvb3RQcm9wcyA9IHVzZVNsb3RQcm9wcyh7XG4gICAgZWxlbWVudFR5cGU6IFJvb3RTbG90LFxuICAgIGV4dGVybmFsU2xvdFByb3BzOiByb290U2xvdFByb3BzLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IG90aGVyLFxuICAgIGFkZGl0aW9uYWxQcm9wczoge1xuICAgICAgcmVmLFxuICAgICAgYXM6IGNvbXBvbmVudFxuICAgIH0sXG4gICAgb3duZXJTdGF0ZSxcbiAgICBjbGFzc05hbWU6IGNsc3gocm9vdFNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcm9vdFNsb3RQcm9wcy5jbGFzc05hbWUsIGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKVxuICB9KTtcbiAgY29uc3QgYmFkZ2VQcm9wcyA9IHVzZVNsb3RQcm9wcyh7XG4gICAgZWxlbWVudFR5cGU6IEJhZGdlU2xvdCxcbiAgICBleHRlcm5hbFNsb3RQcm9wczogYmFkZ2VTbG90UHJvcHMsXG4gICAgb3duZXJTdGF0ZSxcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5iYWRnZSwgYmFkZ2VTbG90UHJvcHMgPT0gbnVsbCA%2FIHZvaWQgMCA6IGJhZGdlU2xvdFByb3BzLmNsYXNzTmFtZSlcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeHMoUm9vdFNsb3QsIF9leHRlbmRzKHt9LCByb290UHJvcHMsIHtcbiAgICBjaGlsZHJlbjogW2NoaWxkcmVuLCAvKiNfX1BVUkVfXyovX2pzeChCYWRnZVNsb3QsIF9leHRlbmRzKHt9LCBiYWRnZVByb3BzLCB7XG4gICAgICBjaGlsZHJlbjogZGlzcGxheVZhbHVlXG4gICAgfSkpXVxuICB9KSk7XG59LCBcImJ1YnBJZ0xaWnRqUjM2OWZRWEhxZDZIekhBUT1cIiwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt1c2VUaGVtZVByb3BzLCB1c2VCYWRnZSwgdXNlUHJldmlvdXNQcm9wcywgdXNlVXRpbGl0eUNsYXNzZXMsIHVzZVNsb3RQcm9wcywgdXNlU2xvdFByb3BzXTtcbn0pKSwgXCJidWJwSWdMWlp0alIzNjlmUVhIcWQ2SHpIQVE9XCIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdXNlVGhlbWVQcm9wcywgdXNlQmFkZ2UsIHVzZVByZXZpb3VzUHJvcHMsIHVzZVV0aWxpdHlDbGFzc2VzLCB1c2VTbG90UHJvcHMsIHVzZVNsb3RQcm9wc107XG59KTtcbl9jMSA9IEJhZGdlO1xuXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA%2FIEJhZGdlLnByb3BUeXBlcyAvKiByZW1vdmUtcHJvcHR5cGVzICovID0ge1xuICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgV2FybmluZyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgLy8g4pSCIFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucy4g4pSCXG4gIC8vIOKUgiAgICBUbyB1cGRhdGUgdGhlbSwgZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gYHBucG0gcHJvcHR5cGVzYC4gICAgIOKUglxuICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgLyoqXG4gICogVGhlIGFuY2hvciBvZiB0aGUgYmFkZ2UuXG4gICogQGRlZmF1bHQge1xuICAqICAgdmVydGljYWw6ICd0b3AnLFxuICAqICAgaG9yaXpvbnRhbDogJ3JpZ2h0JyxcbiAgKiB9XG4gICovXG4gIGFuY2hvck9yaWdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBob3Jpem9udGFsOiBQcm9wVHlwZXMub25lT2YoW1wibGVmdFwiLCBcInJpZ2h0XCJdKS5pc1JlcXVpcmVkLFxuICAgIHZlcnRpY2FsOiBQcm9wVHlwZXMub25lT2YoW1wiYm90dG9tXCIsIFwidG9wXCJdKS5pc1JlcXVpcmVkXG4gIH0pLFxuICAvKipcbiAgKiBUaGUgY29udGVudCByZW5kZXJlZCB3aXRoaW4gdGhlIGJhZGdlLlxuICAqL1xuICBiYWRnZUNvbnRlbnQ6IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgKiBUaGUgYmFkZ2Ugd2lsbCBiZSBhZGRlZCByZWxhdGl2ZSB0byB0aGlzIG5vZGUuXG4gICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvKipcbiAgKiBAaWdub3JlXG4gICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuXG4gICogSXQgc3VwcG9ydHMgYm90aCBkZWZhdWx0IGFuZCBjdXN0b20gdGhlbWUgY29sb3JzLCB3aGljaCBjYW4gYmUgYWRkZWQgYXMgc2hvd24gaW4gdGhlXG4gICogW3BhbGV0dGUgY3VzdG9taXphdGlvbiBndWlkZV0oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL2N1c3RvbWl6YXRpb24vcGFsZXR0ZS8jY3VzdG9tLWNvbG9ycykuXG4gICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICovXG4gIGNvbG9yOiBQcm9wVHlwZXMgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqLy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbXCJkZWZhdWx0XCIsIFwicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcImVycm9yXCIsIFwiaW5mb1wiLCBcInN1Y2Nlc3NcIiwgXCJ3YXJuaW5nXCJdKSwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAvKipcbiAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gIC8qKlxuICAqIFRoZSBjb21wb25lbnRzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUuXG4gICpcbiAgKiBUaGlzIHByb3AgaXMgYW4gYWxpYXMgZm9yIHRoZSBgc2xvdHNgIHByb3AuXG4gICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIGBzbG90c2AgcHJvcCBpbnN0ZWFkLlxuICAqXG4gICogQGRlZmF1bHQge31cbiAgKi9cbiAgY29tcG9uZW50czogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBCYWRnZTogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAgIFJvb3Q6IFByb3BUeXBlcy5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICogVGhlIGV4dHJhIHByb3BzIGZvciB0aGUgc2xvdCBjb21wb25lbnRzLlxuICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGV4aXN0aW5nIHByb3BzIG9yIGFkZCBuZXcgb25lcy5cbiAgKlxuICAqIFRoaXMgcHJvcCBpcyBhbiBhbGlhcyBmb3IgdGhlIGBzbG90UHJvcHNgIHByb3AuXG4gICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIGBzbG90UHJvcHNgIHByb3AgaW5zdGVhZCwgYXMgYGNvbXBvbmVudHNQcm9wc2Agd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuXG4gICpcbiAgKiBAZGVmYXVsdCB7fVxuICAqL1xuICBjb21wb25lbnRzUHJvcHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYmFkZ2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgcm9vdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKVxuICB9KSxcbiAgLyoqXG4gICogSWYgYHRydWVgLCB0aGUgYmFkZ2UgaXMgaW52aXNpYmxlLlxuICAqIEBkZWZhdWx0IGZhbHNlXG4gICovXG4gIGludmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAqIE1heCBjb3VudCB0byBzaG93LlxuICAqIEBkZWZhdWx0IDk5XG4gICovXG4gIG1heDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICogV3JhcHBlZCBzaGFwZSB0aGUgYmFkZ2Ugc2hvdWxkIG92ZXJsYXAuXG4gICogQGRlZmF1bHQgJ3JlY3Rhbmd1bGFyJ1xuICAqL1xuICBvdmVybGFwOiBQcm9wVHlwZXMub25lT2YoW1wiY2lyY3VsYXJcIiwgXCJyZWN0YW5ndWxhclwiXSksXG4gIC8qKlxuICAqIENvbnRyb2xzIHdoZXRoZXIgdGhlIGJhZGdlIGlzIGhpZGRlbiB3aGVuIGBiYWRnZUNvbnRlbnRgIGlzIHplcm8uXG4gICogQGRlZmF1bHQgZmFsc2VcbiAgKi9cbiAgc2hvd1plcm86IFByb3BUeXBlcy5ib29sLFxuICAvKipcbiAgKiBUaGUgcHJvcHMgdXNlZCBmb3IgZWFjaCBzbG90IGluc2lkZSB0aGUgQmFkZ2UuXG4gICogQGRlZmF1bHQge31cbiAgKi9cbiAgc2xvdFByb3BzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGJhZGdlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHJvb3Q6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSlcbiAgfSksXG4gIC8qKlxuICAqIFRoZSBjb21wb25lbnRzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUgdGhlIEJhZGdlLlxuICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICogQGRlZmF1bHQge31cbiAgKi9cbiAgc2xvdHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYmFkZ2U6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcbiAgICByb290OiBQcm9wVHlwZXMuZWxlbWVudFR5cGVcbiAgfSksXG4gIC8qKlxuICAqIFRoZSBzeXN0ZW0gcHJvcCB0aGF0IGFsbG93cyBkZWZpbmluZyBzeXN0ZW0gb3ZlcnJpZGVzIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBDU1Mgc3R5bGVzLlxuICAqL1xuICBzeDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5ib29sXSkpLCBQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAvKipcbiAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICogQGRlZmF1bHQgJ3N0YW5kYXJkJ1xuICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqLy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbXCJkb3RcIiwgXCJzdGFuZGFyZFwiXSksIFByb3BUeXBlcy5zdHJpbmddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IEJhZGdlO1xudmFyIF9jLCBfYzE7XG4kUmVmcmVzaFJlZyQoX2MsIFwiQmFkZ2UkUmVhY3QuZm9yd2FyZFJlZlwiKTtcbiRSZWZyZXNoUmVnJChfYzEsIFwiQmFkZ2VcIik7XG47XG4vLyBXcmFwcGVkIGluIGFuIElJRkUgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBnbG9iYWwgc2NvcGVcbjtcbihmdW5jdGlvbiAoKSB7XG4gIHZhciBfYSwgX2I7XG4gIC8vIExlZ2FjeSBDU1MgaW1wbGVtZW50YXRpb25zIHdpbGwgYGV2YWxgIGJyb3dzZXIgY29kZSBpbiBhIE5vZGUuanMgY29udGV4dFxuICAvLyB0byBleHRyYWN0IENTUy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBuZWVkIHRvIGNoZWNrIHdlJ3JlIGluIGFcbiAgLy8gYnJvd3NlciBjb250ZXh0IGJlZm9yZSBjb250aW51aW5nLlxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gIC8vIEFNUCAvIE5vLUpTIG1vZGUgZG9lcyBub3QgaW5qZWN0IHRoZXNlIGhlbHBlcnM6XG4gICckUmVmcmVzaEhlbHBlcnMkJyBpbiBzZWxmKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBfX3dlYnBhY2tfbW9kdWxlX18gaXMgZ2xvYmFsXG4gICAgdmFyIGN1cnJlbnRFeHBvcnRzID0gX193ZWJwYWNrX21vZHVsZV9fLmV4cG9ydHM7XG4gICAgLy8gQHRzLWlnbm9yZSBfX3dlYnBhY2tfbW9kdWxlX18gaXMgZ2xvYmFsXG4gICAgdmFyIHByZXZTaWduYXR1cmUgPSAoX2IgPSAoX2EgPSBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2U2lnbmF0dXJlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIC8vIFRoaXMgY2Fubm90IGhhcHBlbiBpbiBNYWluVGVtcGxhdGUgYmVjYXVzZSB0aGUgZXhwb3J0cyBtaXNtYXRjaCBiZXR3ZWVuXG4gICAgLy8gdGVtcGxhdGluZyBhbmQgZXhlY3V0aW9uLlxuICAgIHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5yZWdpc3RlckV4cG9ydHNGb3JSZWFjdFJlZnJlc2goY3VycmVudEV4cG9ydHMsIF9fd2VicGFja19tb2R1bGVfXy5pZCk7XG4gICAgLy8gQSBtb2R1bGUgY2FuIGJlIGFjY2VwdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGV4cG9ydHMsIGUuZy4gd2hlblxuICAgIC8vIGl0IGlzIGEgUmVmcmVzaCBCb3VuZGFyeS5cbiAgICBpZiAoc2VsZi4kUmVmcmVzaEhlbHBlcnMkLmlzUmVhY3RSZWZyZXNoQm91bmRhcnkoY3VycmVudEV4cG9ydHMpKSB7XG4gICAgICAvLyBTYXZlIHRoZSBwcmV2aW91cyBleHBvcnRzIHNpZ25hdHVyZSBvbiB1cGRhdGUgc28gd2UgY2FuIGNvbXBhcmUgdGhlIGJvdW5kYXJ5XG4gICAgICAvLyBzaWduYXR1cmVzLiBXZSBhdm9pZCBzYXZpbmcgZXhwb3J0cyB0aGVtc2VsdmVzIHNpbmNlIGl0IGNhdXNlcyBtZW1vcnkgbGVha3MgKGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzUzNzk3KVxuICAgICAgX193ZWJwYWNrX21vZHVsZV9fLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGRhdGEucHJldlNpZ25hdHVyZSA9IHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5nZXRSZWZyZXNoQm91bmRhcnlTaWduYXR1cmUoY3VycmVudEV4cG9ydHMpO1xuICAgICAgfSk7XG4gICAgICAvLyBVbmNvbmRpdGlvbmFsbHkgYWNjZXB0IGFuIHVwZGF0ZSB0byB0aGlzIG1vZHVsZSwgd2UnbGwgY2hlY2sgaWYgaXQnc1xuICAgICAgLy8gc3RpbGwgYSBSZWZyZXNoIEJvdW5kYXJ5IGxhdGVyLlxuICAgICAgLy8gQHRzLWlnbm9yZSBpbXBvcnRNZXRhIGlzIHJlcGxhY2VkIGluIHRoZSBsb2FkZXJcbiAgICAgIGltcG9ydC5tZXRhLndlYnBhY2tIb3QuYWNjZXB0KCk7XG4gICAgICAvLyBUaGlzIGZpZWxkIGlzIHNldCB3aGVuIHRoZSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgbW9kdWxlIHdhcyBhXG4gICAgICAvLyBSZWZyZXNoIEJvdW5kYXJ5LCBsZXR0aW5nIHVzIGtub3cgd2UgbmVlZCB0byBjaGVjayBmb3IgaW52YWxpZGF0aW9uIG9yXG4gICAgICAvLyBlbnF1ZXVlIGFuIHVwZGF0ZS5cbiAgICAgIGlmIChwcmV2U2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEEgYm91bmRhcnkgY2FuIGJlY29tZSBpbmVsaWdpYmxlIGlmIGl0cyBleHBvcnRzIGFyZSBpbmNvbXBhdGlibGVcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgZXhwb3J0cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGlmIHlvdSBhZGQvcmVtb3ZlL2NoYW5nZSBleHBvcnRzLCB3ZSdsbCB3YW50IHRvXG4gICAgICAgIC8vIHJlLWV4ZWN1dGUgdGhlIGltcG9ydGluZyBtb2R1bGVzLCBhbmQgZm9yY2UgdGhvc2UgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyByZS1yZW5kZXIuIFNpbWlsYXJseSwgaWYgeW91IGNvbnZlcnQgYSBjbGFzcyBjb21wb25lbnQgdG8gYVxuICAgICAgICAvLyBmdW5jdGlvbiwgd2Ugd2FudCB0byBpbnZhbGlkYXRlIHRoZSBib3VuZGFyeS5cbiAgICAgICAgaWYgKHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5zaG91bGRJbnZhbGlkYXRlUmVhY3RSZWZyZXNoQm91bmRhcnkocHJldlNpZ25hdHVyZSwgc2VsZi4kUmVmcmVzaEhlbHBlcnMkLmdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZShjdXJyZW50RXhwb3J0cykpKSB7XG4gICAgICAgICAgX193ZWJwYWNrX21vZHVsZV9fLmhvdC5pbnZhbGlkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi4kUmVmcmVzaEhlbHBlcnMkLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2luY2Ugd2UganVzdCBleGVjdXRlZCB0aGUgY29kZSBmb3IgdGhlIG1vZHVsZSwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZVxuICAgICAgLy8gbmV3IGV4cG9ydHMgbWFkZSBpdCBpbmVsaWdpYmxlIGZvciBiZWluZyBhIGJvdW5kYXJ5LlxuICAgICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSBjYXNlIHdoZW4gd2Ugd2VyZSBfcHJldmlvdXNseV8gYSBib3VuZGFyeSxcbiAgICAgIC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBhY2NlcHRlZCB0aGlzIHVwZGF0ZSAoYWNjaWRlbnRhbCBzaWRlIGVmZmVjdCkuXG4gICAgICB2YXIgaXNOb0xvbmdlckFCb3VuZGFyeSA9IHByZXZTaWduYXR1cmUgIT09IG51bGw7XG4gICAgICBpZiAoaXNOb0xvbmdlckFCb3VuZGFyeSkge1xuICAgICAgICBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pKCk7Il19*%2F%22%7D";
import { styled as _styled2 } from "@mui/zero-runtime";
import _theme2 from "@mui/zero-runtime/theme";
import { styled as _styled } from "@mui/zero-runtime";
import _theme from "@mui/zero-runtime/theme";
import { createUseThemeProps as _createUseThemeProps } from "@mui/zero-runtime";
/* __next_internal_client_entry_do_not_use__ default auto */var _s = $RefreshSig$();
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
const _excluded = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"];
import * as React from "react";
import PropTypes from "prop-types";
import clsx from "clsx";
import { usePreviousProps } from "@mui/utils";
import { unstable_composeClasses as composeClasses } from "@mui/base/composeClasses";
import { useBadge } from "@mui/base/useBadge";
import { useSlotProps } from "@mui/base";
import capitalize from "../utils/capitalize";
import { getBadgeUtilityClass } from "./badgeClasses";
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
const useThemeProps = /*#__PURE__*/_createUseThemeProps({
  color: "error"
});
const useUtilityClasses = ownerState => {
  const {
    color,
    anchorOrigin,
    invisible,
    overlap,
    variant,
    classes = {}
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}${capitalize(overlap)}`, `overlap${capitalize(overlap)}`, color !== "default" && `color${capitalize(color)}`]
  };
  return composeClasses(slots, getBadgeUtilityClass, classes);
};
const BadgeRoot = /*#__PURE__*/_styled("span", {
  name: "MuiBadge",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  classes: ["BadgeRoot_bdxyzxj"]
});
const BadgeBadge = /*#__PURE__*/_styled2("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.badge, styles[ownerState.variant], styles[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}${capitalize(ownerState.overlap)}`], ownerState.color !== "default" && styles[`color${capitalize(ownerState.color)}`], ownerState.invisible && styles.invisible];
  }
})({
  classes: ["BadgeBadge_b14y6z35"],
  variants: [{
    props: {
      color: "primary"
    },
    className: "BadgeBadge_b14y6z35-variant"
  }, {
    props: {
      color: "secondary"
    },
    className: "BadgeBadge_b14y6z35-variant-1"
  }, {
    props: {
      color: "error"
    },
    className: "BadgeBadge_b14y6z35-variant-2"
  }, {
    props: {
      color: "warning"
    },
    className: "BadgeBadge_b14y6z35-variant-3"
  }, {
    props: {
      color: "info"
    },
    className: "BadgeBadge_b14y6z35-variant-4"
  }, {
    props: {
      color: "success"
    },
    className: "BadgeBadge_b14y6z35-variant-5"
  }, {
    props: {
      variant: "dot"
    },
    className: "BadgeBadge_b14y6z35-variant-6"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    className: "BadgeBadge_b14y6z35-variant-7"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    className: "BadgeBadge_b14y6z35-variant-8"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    className: "BadgeBadge_b14y6z35-variant-9"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    className: "BadgeBadge_b14y6z35-variant-10"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    className: "BadgeBadge_b14y6z35-variant-11"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    className: "BadgeBadge_b14y6z35-variant-12"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    className: "BadgeBadge_b14y6z35-variant-13"
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    className: "BadgeBadge_b14y6z35-variant-14"
  }, {
    props: {
      invisible: true
    },
    className: "BadgeBadge_b14y6z35-variant-15"
  }]
});
const Badge = /*#__PURE__*/_s(React.forwardRef(_c = _s(function Badge(inProps, ref) {
  _s();
  var _ref, _slots$root, _ref2, _slots$badge, _slotProps$root, _slotProps$badge;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBadge"
  });
  const {
      anchorOrigin: anchorOriginProp = {
        vertical: "top",
        horizontal: "right"
      },
      className,
      component,
      components = {},
      componentsProps = {},
      children,
      overlap: overlapProp = "rectangular",
      color: colorProp = "default",
      invisible: invisibleProp = false,
      max: maxProp = 99,
      badgeContent: badgeContentProp,
      slots,
      slotProps,
      showZero = false,
      variant: variantProp = "standard"
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded);
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max,
    displayValue: displayValueFromHook
  } = useBadge({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = usePreviousProps({
    anchorOrigin: anchorOriginProp,
    color: colorProp,
    overlap: overlapProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
  const {
    color = colorProp,
    overlap = overlapProp,
    anchorOrigin = anchorOriginProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const displayValue = variant !== "dot" ? displayValueFromHook : undefined;
  const ownerState = _extends({}, props, {
    badgeContent,
    invisible,
    max,
    displayValue,
    showZero,
    anchorOrigin,
    color,
    overlap,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  // support both `slots` and `components` for backward compatibility
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : BadgeRoot;
  const BadgeSlot = (_ref2 = (_slots$badge = slots == null ? void 0 : slots.badge) != null ? _slots$badge : components.Badge) != null ? _ref2 : BadgeBadge;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const badgeSlotProps = (_slotProps$badge = slotProps == null ? void 0 : slotProps.badge) != null ? _slotProps$badge : componentsProps.badge;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
  });
  const badgeProps = useSlotProps({
    elementType: BadgeSlot,
    externalSlotProps: badgeSlotProps,
    ownerState,
    className: clsx(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
  });
  return /*#__PURE__*/_jsxs(RootSlot, _extends({}, rootProps, {
    children: [children, /*#__PURE__*/_jsx(BadgeSlot, _extends({}, badgeProps, {
      children: displayValue
    }))]
  }));
}, "bubpIgLZZtjR369fQXHqd6HzHAQ=", false, function () {
  return [useThemeProps, useBadge, usePreviousProps, useUtilityClasses, useSlotProps, useSlotProps];
})), "bubpIgLZZtjR369fQXHqd6HzHAQ=", false, function () {
  return [useThemeProps, useBadge, usePreviousProps, useUtilityClasses, useSlotProps, useSlotProps];
});
_c1 = Badge;
"development" !== "production" ? Badge.propTypes /* remove-proptypes */ = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
  * The anchor of the badge.
  * @default {
  *   vertical: 'top',
  *   horizontal: 'right',
  * }
  */
  anchorOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOf(["left", "right"]).isRequired,
    vertical: PropTypes.oneOf(["bottom", "top"]).isRequired
  }),
  /**
  * The content rendered within the badge.
  */
  badgeContent: PropTypes.node,
  /**
  * The badge will be added relative to this node.
  */
  children: PropTypes.node,
  /**
  * Override or extend the styles applied to the component.
  */
  classes: PropTypes.object,
  /**
  * @ignore
  */
  className: PropTypes.string,
  /**
  * The color of the component.
  * It supports both default and custom theme colors, which can be added as shown in the
  * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
  * @default 'default'
  */
  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
  * The component used for the root node.
  * Either a string to use a HTML element or a component.
  */
  component: PropTypes.elementType,
  /**
  * The components used for each slot inside.
  *
  * This prop is an alias for the `slots` prop.
  * It's recommended to use the `slots` prop instead.
  *
  * @default {}
  */
  components: PropTypes.shape({
    Badge: PropTypes.elementType,
    Root: PropTypes.elementType
  }),
  /**
  * The extra props for the slot components.
  * You can override the existing props or add new ones.
  *
  * This prop is an alias for the `slotProps` prop.
  * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
  *
  * @default {}
  */
  componentsProps: PropTypes.shape({
    badge: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
  * If `true`, the badge is invisible.
  * @default false
  */
  invisible: PropTypes.bool,
  /**
  * Max count to show.
  * @default 99
  */
  max: PropTypes.number,
  /**
  * Wrapped shape the badge should overlap.
  * @default 'rectangular'
  */
  overlap: PropTypes.oneOf(["circular", "rectangular"]),
  /**
  * Controls whether the badge is hidden when `badgeContent` is zero.
  * @default false
  */
  showZero: PropTypes.bool,
  /**
  * The props used for each slot inside the Badge.
  * @default {}
  */
  slotProps: PropTypes.shape({
    badge: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
  * The components used for each slot inside the Badge.
  * Either a string to use a HTML element or a component.
  * @default {}
  */
  slots: PropTypes.shape({
    badge: PropTypes.elementType,
    root: PropTypes.elementType
  }),
  /**
  * The system prop that allows defining system overrides as well as additional CSS styles.
  */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
  * The variant to use.
  * @default 'standard'
  */
  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(["dot", "standard"]), PropTypes.string])
} : void 0;
export default Badge;
var _c, _c1;
$RefreshReg$(_c, "Badge$React.forwardRef");
$RefreshReg$(_c1, "Badge");
;
// Wrapped in an IIFE to avoid polluting the global scope
;
(function () {
  var _a, _b;
  // Legacy CSS implementations will `eval` browser code in a Node.js context
  // to extract CSS. For backwards compatibility, we need to check we're in a
  // browser context before continuing.
  if (typeof self !== 'undefined' &&
  // AMP / No-JS mode does not inject these helpers:
  '$RefreshHelpers$' in self) {
    // @ts-ignore __webpack_module__ is global
    var currentExports = __webpack_module__.exports;
    // @ts-ignore __webpack_module__ is global
    var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;
    // This cannot happen in MainTemplate because the exports mismatch between
    // templating and execution.
    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);
    // A module can be accepted automatically based on its exports, e.g. when
    // it is a Refresh Boundary.
    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
      // Save the previous exports signature on update so we can compare the boundary
      // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)
      __webpack_module__.hot.dispose(function (data) {
        data.prevSignature = self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);
      });
      // Unconditionally accept an update to this module, we'll check if it's
      // still a Refresh Boundary later.
      // @ts-ignore importMeta is replaced in the loader
      import.meta.webpackHot.accept();
      // This field is set when the previous version of this module was a
      // Refresh Boundary, letting us know we need to check for invalidation or
      // enqueue an update.
      if (prevSignature !== null) {
        // A boundary can become ineligible if its exports are incompatible
        // with the previous exports.
        //
        // For example, if you add/remove/change exports, we'll want to
        // re-execute the importing modules, and force those components to
        // re-render. Similarly, if you convert a class component to a
        // function, we want to invalidate the boundary.
        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {
          __webpack_module__.hot.invalidate();
        } else {
          self.$RefreshHelpers$.scheduleUpdate();
        }
      }
    } else {
      // Since we just executed the code for the module, it's possible that the
      // new exports made it ineligible for being a boundary.
      // We only care about the case when we were _previously_ a boundary,
      // because we already accepted this update (accidental side effect).
      var isNoLongerABoundary = prevSignature !== null;
      if (isNoLongerABoundary) {
        __webpack_module__.hot.invalidate();
      }
    }
  }
})();