# Customizing components

<p class="description">You can easily customize the appearance of a Material-UI component.</p>

As components can be used in different contexts, there are several approaches to this. Going from the narrowest use-case to the broadest, these are:

1. [One-time customization](#1-one-time-customization)
1. [Reusable style overrides](#2-reusable-style-overrides)
1. [Dynamic variation](#3-dynamic-variation)
1. [Global theme variation](#5-global-theme-variation)

## 1. Specific variation for a one-time situation

You might need to change the style of a component for a specific implementation, for which you have the following solutions available:

### Use the `sx` prop

The easiest way to add style overrides for a one-time situation is to use the `sx` prop available on all Material-UI components. Here is an example of it:

{{"demo": "pages/customization/components/SxProp.js"}}

You may see in the examples, that you may use global class selectors as well for accessing slots inside the component, as well as theme callback for getting access to the theme.

```jsx
<Slider
  defaultValue={30}
  sx={{
    width: 300,
    color: 'success.main',
    '& .MuiSlider-thumb': {
      borderRadius: 0,
    },
  }}
/>
```

### Overriding styles with class names

If you would like to override the styles of the components using classes, you can use the `className` property available on each component. For overriding the styles of the slots inside the component, you may use the global classes available for each slot, or you may add custom classes using the `componentsProps` API.

You may find different interoperability examples on the [Styles library interoperability](/guides/interoperability/) guide.

### Pseudo-classes

The components special states, like _hover_, _focus_, _disabled_ and _selected_, are styled with a higher CSS specificity.
[Specificity is a weight](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity) that is applied to a given CSS declaration.

In order to override the components special states, **you need to increase specificity**.
Here is an example with the _disable_ state and the button component using a **pseudo-class** (`:disabled`):

```css
.Slider {
  color: black;
}
/* Increase the specificity */
.Slider:disabled {
  color: white;
}
```

```jsx
<Slider disabled className="Slider">
```

Sometimes, you can't use a **pseudo-class** as the state doesn't exist in the platform.
Let's take the menu item component and the _selected_ state as an example.
You can use the `.Mui-selected` global class name to customize the special state of the `MenuItem` component:

```css
.MenuItem {
  color: black;
}
/* Increase the specificity */
.MenuItem.Mui-selected {
  color: blue;
}
```

```jsx
<MenuItem selected className="MenuItem">
```

#### Why do I need to increase specificity to override one component state?

By design, the CSS specification makes the pseudo-classes increase the specificity.
For consistency, Material-UI increases the specificity of its custom pseudo-classes.
This has one important advantage, it allows you to cherry-pick the state you want to customize.

#### What custom pseudo-classes are available in Material-UI?

You can rely on the following [global class names](/styles/advanced/#with-material-ui-core) generated by Material-UI:

| State  | Global class name |
| :----------- | :---------------- |
| checked      | Mui-checked       |
| disabled     | Mui-disabled      |
| error        | Mui-error         |
| focused      | Mui-focused       |
| focusVisible | Mui-focusVisible  |
| required     | Mui-required      |
| expanded     | Mui-expanded      |
| selected     | Mui-selected      |

### Overriding with inline-styles

The second way to override the style of a component is to use the **inline-style** approach.
Every component provides a `style` prop. These props are always applied to the root element.

You don't have to worry about CSS specificity as the inline-style takes precedence over the regular CSS.

{{"demo": "pages/customization/components/InlineStyle.js"}}

[When should I use inline-style vs classes?](/getting-started/faq/#when-should-i-use-inline-style-vs-css)

## 2. Specific variations for reusable style overrides

If you see yourself needing the same overrides on multiple places across your application, you can use the `experimentalStyled()` utility for creating a reusable component:

```js
import { experimentalStyled() as styled } from `@mateial-ui/core/styles`;
```

{{"demo": "pages/customization/components/StyledCustomization.js"}}

You have with it access to all components props to dynamically style the component.

## 3. Dynamic variation for a one-time situation

You have learned how to override the style of a Material-UI component in the previous section.
Now, let's see how we can make these overrides dynamic.
Here are five alternatives; each has its pros and cons.

### Dynamic CSS

{{"demo": "pages/customization/components/DynamicCSS.js"}}

### Class name branch

{{"demo": "pages/customization/components/DynamicClassName.js"}}

### CSS variables

{{"demo": "pages/customization/components/DynamicCSSVariables.js"}}

### Inline-styles

{{"demo": "pages/customization/components/DynamicInlineStyle.js"}}

### Theme nesting

{{"demo": "pages/customization/components/DynamicThemeNesting.js"}}

## 4. Material Design variations

The Material Design specification documents different variations of certain components, such as how buttons come in different shapes: [text](https://material.io/design/components/buttons.html#text-button) (formerly "flat"), [contained](https://material.io/design/components/buttons.html#contained-button) (formerly "raised"), [FAB](https://material.io/design/components/buttons-floating-action-button.html) and more.

Material-UI attempts to implement all of these variations. Please refer to the [Supported Components](/getting-started/supported-components/) documentation to find out the current status of all supported Material Design components.

## 5. Global theme variation

In order to promote consistency between components, and manage the user interface appearance as a whole, Material-UI provides a mechanism to apply global changes.

The demos of this section covers how to the change the button's font size.

### Theme variables

You can adjust the [theme configuration variables](/customization/theming/#theme-configuration-variables).

```jsx
const theme = createMuiTheme({
  typography: {
    button: {
      fontSize: '1rem',
    },
  },
});
```

{{"demo": "pages/customization/components/ThemeVariables.js"}}

### Global CSS override

You can also customize all instances of a component with CSS.
Components expose [global class names](/styles/advanced/#with-material-ui-core) to enable this.
It's very similar to how you would customize Bootstrap.

```jsx
const GlobalCss = withStyles({
  // @global is handled by jss-plugin-global.
  '@global': {
    // You should target [class*="MuiButton-root"] instead if you nest themes.
    '.MuiButton-root': {
      fontSize: '1rem',
    },
  },
})(() => null);

// â€¦

<GlobalCss />;
```

{{"demo": "pages/customization/components/GlobalCssOverride.js", "iframe": true, "height": 70}}

### Global theme override

You can take advantage of the `overrides` key of the `theme` to potentially change every single style injected by Material-UI into the DOM.
Learn more about it in the [themes section](/customization/globals/#css) of the documentation.

```jsx
const theme = createMuiTheme({
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          fontSize: '1rem',
        },
      },
    },
  },
});
```

{{"demo": "pages/customization/components/GlobalThemeOverride.js"}}

### Adding new component variants

You can take advantage of the `variants` key in the `theme`'s components section to add new variants to Material-UI components. These new variants, can specify which styles the component should have, if specific props are defined together.

The definitions are specified in an array, under the component's name. For every one of them a class is added in the head. The order is **important**, so make sure that the styles that should win will be specified lastly.

```jsx
const theme = createMuiTheme({
  components: {
    MuiButton: {
      variants: [
        {
          props: { variant: 'dashed' },
          style: {
            textTransform: 'none',
            border: `2px dashed grey${blue[500]}`,
          },
        },
        {
          props: { variant: 'dashed', color: 'secondary' },
          style: {
            border: `4px dashed ${red[500]}`,
          },
        },
      ],
    },
  },
});
```

If you are using TypeScript, you will need to specify your new variants/colors, using [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).

```tsx
declare module '@material-ui/core/Button/Button' {
  interface ButtonPropsVariantOverrides {
    dashed: true;
  }
}
```

{{"demo": "pages/customization/components/GlobalThemeVariants.js"}}
