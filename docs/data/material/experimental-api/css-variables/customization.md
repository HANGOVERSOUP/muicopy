# Customization

<p class="description">CSS variables customization guide.</p>

## Theming

The new API to extend the default theme is called `experimental_extendTheme`. It returns a theme that can only be used by `CssVarsProvider`.

```js
import {
  Experimental_CssVarsProvider as CssVarsProvider,
  experimental_extendTheme as extendTheme,
} from '@mui/material/styles';

const theme = extendTheme();
// ...custom theme

function App() {
  return <CssVarsProvider theme={theme}>...</CssVarsProvider>;
}
```

:::warning
The `extendTheme` is not the same as `createTheme`, do not use theme interchangably.

- `createTheme()` returns a theme for `ThemeProvider`.
- `extendTheme()` returns a theme for `CssVarsProvider`.
  :::

### Color schemes

The major difference from the conventional approach is the palette customization. With the new `extendTheme` API, you can specify the palette for all color schemes at once (`light` and `dark` are built-in color schemes).

Here is an example of customizing the `primary` palette:

```js
import { pink } from '@mui/material/colors';

const theme = extendTheme({
  colorSchemes: {
    light: {
      palette: {
        primary: {
          main: pink[600],
        },
      },
    },
    dark: {
      palette: {
        primary: {
          main: pink[400],
        },
      },
    },
  },
});
```

### Components

Customizing components remains the same. We recommend to use the value from `theme.vars` whenever possible:

```js
const theme = extendTheme({
  components: {
    MuiChip: {
      styleOverrides: {
        root: ({ theme, ownerState }) => ({
          ...(ownerState.variant === 'outlined' &&
            ownerState.color === 'primary' && {
              // this is the same as writing:
              // backgroundColor: 'var(--mui-palette-background-paper)',
              backgroundColor: theme.vars.palette.background.paper,
            }),
        }),
      },
    },
  },
});
```

### Auto-generated colors

There are some cases where you want to manipulate the alpha channel of a color. The only practical way to do that using CSS variables is to store the color's channel in a variable and use it like this:

```css
--color-channel: 0 114 229;
color: rgba(var(--color-channel) / 0.6);
```

With this concept, the `extendTheme()` auto generates some channel colors that are likely to be used frequently from the theme palette. Those colors are suffixed with `*Channel`:

- `common.backgroundChannel` ðŸ‘‰ `common.background`
- `common.onBackgroundChannel` ðŸ‘‰ `common.onBackground`
- `dividerChannel` ðŸ‘‰ `divider`
- `primary.mainChannel` ðŸ‘‰ `primary.main`
- `primary.lightChannel` ðŸ‘‰ `primary.light`
- `primary.darkChannel` ðŸ‘‰ `primary.dark`
- `primary.contrastTextChannel` ðŸ‘‰ `primary.contrastText`
- ...same as `secondary`, `error`, `info`, `success`, `warning` palettes

> ðŸ‘‰ = the color on the left is generated by the color on the right-hand side.

You can use those tokens to create a translucent color like this:

```js
const theme = extendTheme({
  components: {
    MuiChip: {
      styleOverrides: {
        root: ({ theme, ownerState }) => ({
          ...(ownerState.variant === 'outlined' &&
            ownerState.color === 'primary' && {
              backgroundColor: `rgba(${theme.vars.palette.primary.mainChannel} / 0.12)`,
            }),
        }),
      },
    },
  },
});
```

:::warning
Don't use comma(`,`) as a separator because the result is not a valid format in CSS:

```js
`rgba(${theme.vars.palette.primary.mainChannel}, 0.12)`, // ðŸš« this does not work
`rgba(${theme.vars.palette.primary.mainChannel} / 0.12)`, // âœ… always use `/`
```

:::

## Adding new theme tokens

You are free to add any key-value pairs to the theme input which will be generated to CSS variables by `CssVarsProvider`.

```js
const theme = extendTheme({
  colorSchemes: {
    light: {
      palette: {
        // Thanks to CSS variables, you can refer to it wherever you like ðŸ¤©
        gradient:
          'linear-gradient(to left, var(--mui-palete-primary-main), var(--mui-palette-primary-dark))',
        border: {
          subtle: 'var(--mui-palette-neutral-200)',
        },
      },
    },
    dark: {
      palette: {
        gradient:
          'linear-gradient(to left, var(--mui-palete-primary-light), var(--mui-palette-primary-main))',
        border: {
          subtle: 'var(--mui-palette-neutral-600)',
        },
      },
    },
  },
});

function App() {
  return <CssVarsProvider theme={theme}>...</CssVarsProvider>;
}
```

You should the new variables in the stylesheet DevTool:

```css
:root {
  --mui-palette-gradient: linear-gradient(
    to left,
    var(--mui-palete-primary-main),
    var(--mui-palette-primary-dark)
  );
  --mui-palette-border-subtle: var(--mui-palette-neutral-200);
}

[data-mui-color-scheme='dark'] {
  --mui-palette-gradient: linear-gradient(
    to left,
    var(--mui-palete-primary-light),
    var(--mui-palette-primary-main)
  );
  --mui-palette-border-subtle: var(--mui-palette-neutral-600);
}
```

You can access those variables in the theme like usual:

```js
// This component works in both `light` and `dark` mode!
const Divider = styled('hr')(({ theme }) => ({
  height: 1,
  backgroundColor: theme.vars.palette.border.subtile,
}));
```

## Changing variable prefix

The default prefix is `mui`. You can change the prefix by passing `cssVarPrefix: string` to `extendTheme`.

```js
const theme = extendTheme({ cssVarPrefix: 'any' });

// the stylesheet will be like this:
// --any-palette-primary-main: ...;
```

You can also provide an empty string (`''`) to remove the default prefix from all variables.

```js
const theme = extendTheme({ cssVarPrefix: '' });

// the stylesheet will be like this:
// --palette-primary-main: ...;
```

## Custom styles per mode

In some cases, creating new tokens might not be a good approach especially if you want to customize just once without reusing in other places.

A better way is to use theme utility to create CSS attribute selector:

```js
const Button = styled('button')(({ theme }) => ({
  backgroundColor: theme.vars.palette.primary.main,
  color: '#fff',
  '&:hover': {
    backgroundColor: theme.vars.palette.primary.dark,
  },
  // this is the same as writing:
  // '[data-mui-color-scheme="dark"] &': { ... }
  [theme.getColorSchemeSelector('dark')]: {
    backgroundColor: theme.vars.palette.primary.dark,
    color: theme.vars.palette.primary.main,
    '&:hover': {
      color: '#fff',
      backgroundColor: theme.vars.palette.primary.dark,
    },
  },
}));
```

:::info
This approach works well for custom components but not that great for building theme because the `theme.getColorSchemeSelector('dark')` create CSS specificity which makes the customization a little bit harder.

A better way is to use [`(:where)()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:where) selector which does not create CSS specifycity. Check out the next section on how to apply it in your project.
:::

### Using `:where` selector

This is a workaround to use the selector because there is a known issue with [emotion](https://github.com/emotion-js/emotion/issues/2836) and styled-components.

#### Emotion

Pass a custom stylis plugin to `createCache()`:

```js
import { CacheProvider } from '@emotion/react';
import createCache from '@emotion/cache';

const enableWhereSelector = (element) => {
  switch (element.type) {
    case 'rule':
      element.props = element.props.map((value) => {
        if (value.match(/(:where)\(/)) {
          value = value.replace(/\.[^:]+(:where)/, '$1');
        }
        return value;
      });
  }
};

const cache = createCache({
  key: 'css',
  prepend: true,
  stylisPlugins: [enableWhereSelector],
});

function App() {
  return (
    <CacheProvider value={cache}>
      <CssVarsProvider>...</CssVarsProvider>
    </CacheProvider>
  );
}
```

## Force a specific mode

Specify `data-mui-color-scheme="dark"` to any DOM node to force the children components to appear as if they are in dark mode.

```js
<div data-mui-color-scheme="dark">
  <Paper sx={{ p: 2 }}>
    <TextField label="Email" type="email" margin="normal" />
    <TextField label="Password" type="password" margin="normal" />
    <Button>Sign in</Button>
  </Paper>
</div>
```

## Support only dark mode

You can specify `defaultMode="dark"` to make the application initially appears dark and then delete the `light` color scheme to optimize the bundle size:

```js
const theme = extendTheme({
  // ...
});

delete theme.colorSchemes.light;

function App() {
  return (
    <CssVarsProvider theme={theme} defaultMode="dark">
      ...
    </CssVarsProvider>
  );
}
```

## Reusing elevation
